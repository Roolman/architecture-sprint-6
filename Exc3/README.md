# Задание 3

[Ссылка на схему TO BE](https://drive.google.com/file/d/17Ips30i0PvvoLvwLfFoRsqzSve8akK1C/view?usp=sharing)

Ниже приведён короткий список текущих проблем и рисков, связанных с ростом числа страховых компаний и увеличением нагрузки, а также как предложенные решения помогут справиться с возросшей нагрузкой.

## 1. Список проблем и рисков при планируемом росте

1. **Увеличение числа внешних API-запросов**

   - Сейчас сервис **ins-product-aggregator** обращается к пяти страховым компаниям. При добавлении ещё пяти — число внешних REST-вызовов удвоится.
   - В периоды пиковых запросов это может привести к задержкам или ошибкам (time­out).

2. **Частые синхронные запросы внутри системы**

   - Сервис **core-app** каждые 15 минут запрашивает агрегированные данные у **ins-product-aggregator**.
   - Сервис **ins-comp-settlement** раз в сутки (но «большим» запросом) тоже обращается к aggregator.
   - Любая задержка или ошибка в aggregator (например, при неполадках у внешних страховых компаний) приводит к сбою на стороне core-app/ins-comp-settlement и потенциально блокирует их работу.

3. **Сложность длительных/массовых запросов**

   - **core-app** делает 15-минутные полные обновления. Каждый новый цикл перетягивает все данные. При увеличении ассортимента (новые компании, новые продукты) объём передаваемых данных растёт. Это влияет на время отклика и рискует «забить» aggregator.
   - **ins-comp-settlement** (раз в сутки) тоже загружает все продукты и/или все оформленные полисы из core-app. С ростом транзакций это может стать «тяжёлым» запросом, вызывая задержки.

4. **Зависимость от синхронной доступности aggregator**

   - Если aggregator не отвечает (нагрузка, ошибка внешних API), **core-app** и **ins-comp-settlement** «зависают» или возвращают ошибку.
   - Масштабирование aggregator и внешних вызовов также усложняется.

5. **Избыточные передачи данных**

   - При pull-модели (core-app / settlement) происходит полная загрузка данных (даже если изменения минимальны).
   - С ростом ассортимента/числа компаний это становится всё более неэффективным и нагружает сеть и aggregator.

## 2. Предлагаемые решения

### 2.1 Переход к Event-Driven взаимодействию

**Суть**: Вместо регулярных синхронных «pull-запросов» (core-app/settlement → aggregator), сервис **ins-product-aggregator** будет сам публиковать события/сообщения о появлении новых или изменённых продуктов в Event Streaming (например Kafka).

- **core-app** и **ins-comp-settlement** подписываются на «product updates» и асинхронно получают только изменения, без постоянных больших опросов.
- При этом **ins-product-aggregator** может сам определить оптимальное расписание для синхронных API-вызовов к страховым компаниям (или реагировать на webhooks). Результаты изменений публикуются в брокер.

**Преимущества при росте нагрузки**:

1. **Уход от пулла «каждые 15 мин / сутки»**

   - Больше не нужно одновременно гонять весь список продуктов: при росте числа компаний / ассортимента это становится неэффективным.
   - «Push»-модель через события отправляет только изменения.

2. **Развязка по времени (асинхронность)**

   - Если aggregator задерживается при внешних API, это не блокирует core-app и ins-comp-settlement напрямую. Они обновят свои локальные копии продуктов, когда данные появятся.
   - Проблемы во внешних API не «ломают» цепочку синхронных вызовов.

3. **Лучшая масштабируемость**
   - Kafka поддерживает линейное масштабирование подписчиков и поставщиков.
   - aggregator может быть масштабирован отдельно, без навешивания периодических pull-запросов.

### 2.2 Публикация оформленных страховок (событий) из core-app

- Ранее **ins-comp-settlement** ежесуточно делал REST-запрос в **core-app**, получая полный список оформленных полисов.
- Предлагается, чтобы **core-app** при каждом новом оформлении (или изменении статуса) **публиковал** событие «InsuranceIssued» (или «PolicyCreated») в тот же Event Bus.
- **ins-comp-settlement** подписывается и формирует свой реестр.
- Таким образом, settlement не ждёт конца суток и не делает «большой запрос». Он «в реальном времени» (или близко к нему) получает нужную информацию.

**Преимущества**:

1. **Равномерная нагрузка**: вместо одного большого «списка на сутки» сервис получает события по мере их возникновения.
2. **Нет синхронной зависимости**: сбой core-app не блокирует settlement, а сбой settlement не мешает core-app оформлять новые полисы.
3. **Упрощённая обработка**: settlement может агрегировать данные из потока, хранить у себя, и к моменту «закрытия реестра» всё уже готово.

### 2.3 Использование Transactional Outbox в core-app

**Transactional Outbox** — паттерн, при котором при оформлении транзакции (создании полиса) сервис **core-app** записывает событие в специальную таблицу (Outbox) в той же БД. Отдельный Outbox-процесс (или библиотека) публикует эти события в Event Bus «гарантированно», избегая расхождений между данными (полис в БД) и отправленным событием.

**Преимущества**:

1. **Гарантированная доставляемость**: исключаются ситуации, когда полис создался, но событие не ушло в брокер из-за сбоя.
2. **Упрощает отладку**: все события в Outbox-таблице видны администратору.
3. **Хорошо масштабируется**: отдельный поток читает outbox и пушит в брокер.

## 3. Как предложенные решения помогают при росте нагрузки

1. **Снижение нагрузки на aggregator**

   - aggregator не будет получать множество периодических pull-вызовов (особенно с большим числом компаний).
   - Он только периодически (или по webhook) опрашивает внешние API и публикует изменения.
   - При добавлении ещё 5 компаний это не вызовет кратного роста синхронных запросов из core-app/ins-comp-settlement; aggregator масштабируется отдельно.

2. **Избежание «больших» REST-запросов**

   - core-app и ins-comp-settlement получают только изменения через событие, а не полную копию продуктов. При большом росте ассортимента это существенно экономит трафик и время.
   - ins-comp-settlement не делает «полный список оформленных полисов»; он в режиме real-time (или near real-time) слушает события «InsuranceIssued».

3. **Асинхронность**

   - Системы становятся слабосвязаны: если aggregator временно недоступен или внешние страховые компании отвечают медленно, это не блокирует core-app.
   - ins-comp-settlement может продолжать работать со своей локальной копией данных и собирает полисы по событиям. При возобновлении работы aggregator, новые данные «догонят» подписчиков.

4. **Горизонтальное масштабирование**

   - Брокер (Kafka) хорошо масштабируется при большом количестве сообщений. aggregator можно реплицировать, core-app тоже можно реплицировать, без увеличения сложных pull-операций.
   - InsureTech сможет поддерживать более крупный трафик и больше партнёрских страховых компаний без «взрывного» роста длительных REST-запросов.

5. **Повышение надёжности**
   - С помощью **Transactional Outbox** мы гарантируем, что все оформленные страховые полисы будут «сигнализированы» ins-comp-settlement даже при сбоях сети / ребуте сервисов.
   - aggregator не блокирует синхронные запросы core-app/settlement, снижая риск cascade failures.

Итого, переход на **Event-Driven** архитектуру и использование **Transactional Outbox** устраняет узкие места при расширении количества страховых компаний и при увеличении транзакционной нагрузки. Каждый сервис изолирован от задержек в другом, получает необходимые данные в **асинхронном** режиме, а система становится более масштабируемой и надёжной по мере роста бизнеса.

## 4. Ключевые изменения на схеме

1. **Добавлен** новый контейнер: **Event Streaming** (Kafka).
2. **Убраны** периодические REST-запросы между core-app / ins-comp-settlement и aggregator (каждые 15 минут / раз в сутки). Вместо этого:
   - **aggregator** → **Event Streaming**: «Product updates» (publish)
   - **Event Streaming** → **core-app**, **ins-comp-settlement**: «Subscribe product updates»
3. **Добавлен** поток событий при оформлении полисов:
   - **core-app** → **Event Streaming**: «InsuranceIssued»
   - **Event Streaming** → **ins-comp-settlement**: «Subscribe: InsuranceIssued»
4. Добавлен **Transactional Outbox** внутри core-app при создании полисов, чтобы гарантировать доставку событий.
5. В итоге вся система строится вокруг паттерна «publish/subscribe» через Event Bus, а не на синхронном pull (REST) для продуктовых данных и реестров полисов.
