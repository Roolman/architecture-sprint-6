# Задание 4

[Ссылка на схему TO BE](https://drive.google.com/file/d/1aLDLLT7loJBm9mfIVs8rBIyXGvM4NnvQ/view?usp=sharing)

Мы вводим новый сервис **osago‑aggregator**, который получает OSAGO‑заявку от **core‑app** через REST API, отправляет её (с использованием стандартных однотипных REST‑эндпоинтов) в страховые компании, агрегирует их ответы и публикует результаты в шину событий (Kafka). Полученные ответы затем асинхронно доставляются обратно в **core‑app**. Для обновления пользовательского интерфейса в веб‑приложении **core‑app** используется механизм long polling, что упрощает реализацию и снижает нагрузку.

Между **core‑app** и **osago‑aggregator** используется синхронный REST‑вызов, к которому применены три паттерна отказоустойчивости: **TimeOut**, **Retry** и **Circuit Breaker**. Эти механизмы помогают ограничить время ожидания, автоматически повторять запрос при кратковременных сбоях и защищать систему от каскадных отказов. Использование Rate Limiting на данном участке считается избыточным, поскольку вызовы происходят внутри кластера Kubernetes, где масштабирование и балансировка нагрузки уже обеспечены.

Сервисы развёрнуты в нескольких экземплярах (реплицированы в кластере Kubernetes), что обеспечивает горизонтальную масштабируемость и высокую отказоустойчивость.

## Дополнительные пояснения

1. **Требуется ли osago‑aggregator своё хранилище данных?**  
   **Ответ:**  
   Нет. Функциональная обязанность osago‑aggregator — получение заявки, ретрансляция запроса к страховым компаниям и агрегация ответов, что выполняется в реальном времени. Поскольку заявки ОСАГО генерируются индивидуально и повторные запросы по одним и тем же параметрам встречаются редко, достаточно кратковременного in‑memory кэширования, если оно потребуется, а постоянное хранилище не требуется.

2. **Какой API он предоставляет core‑app?**  
   **Ответ:**  
   osago‑aggregator предоставляет REST‑API для создания заявки на ОСАГО. Этот API принимает данные о транспортном средстве и водителе, инициирует опрос страховых компаний и возвращает немедленное подтверждение приёма заявки. Последующие ответы передаются асинхронно через систему Event Streaming.

3. **Определите средство интеграции между сервисами core‑app и osago‑aggregator.**  
   **Ответ:**  
   Интеграция между core‑app и osago‑aggregator реализована посредством синхронного REST‑вызова. Для повышения отказоустойчивости на этом участке применяются паттерны TimeOut, Retry и Circuit Breaker, что помогает защитить систему от задержек и сбоев при пиковых нагрузках.

4. **Подумайте над API для веб‑приложения в core‑app.**  
   **Ответ:**  
   Веб‑приложение взаимодействует с core‑app через стандартные REST‑API для большинства операций (просмотр продуктов, аутентификация и т.д.). Для модуля ОСАГО обновления предложений осуществляются через специальный endpoint, который поддерживает механизм long polling для получения обновлений по мере появления новых предложений.

5. **Определите средство интеграции между веб‑приложением и core‑app. Если будете использовать средство, отличное от REST, отразите интеграцию новой стрелкой.**  
   **Ответ:**  
   Для обновления предложений ОСАГО веб‑приложение подключается к core‑app через long polling. Этот механизм по-прежнему использует HTTP, но позволяет клиенту «подтягивать» обновлённые данные по истечении тайм‑аута или сразу после их появления. Такой подход упрощает реализацию и снижает нагрузку, если мгновенная реакция не является критичной. Websockets считаем избыточным для данного кейса.

6. **Потребуется ли применение паттернов отказоустойчивости и какие именно?**  
   **Ответ:**  
   Для вызовов между **core‑app** и **osago‑aggregator** применяются следующие паттерны:

   - **TimeOut:** Ограничивает время ожидания ответа, чтобы избежать зависания запросов.
   - **Retry:** Позволяет автоматически повторить запрос в случае временных сбоев.
   - **Circuit Breaker:** Предотвращает дальнейшие попытки вызова, если сервис недоступен, чтобы избежать перегрузки и каскадных отказов.  
     Паттерн **Rate Limiting** здесь не применяется, так как вызовы осуществляются в рамках внутренней сети и управляются Kubernetes.

7. **Задеплоены ли сервисы в нескольких экземплярах и зависит ли решение от этого?**  
   **Ответ:**  
   Решение не зависит от наличия нескольких экземпляров, так как все сервисы развёрнуты как реплики в Kubernetes. Это обеспечивает горизонтальную масштабируемость и высокую отказоустойчивость, а применение паттернов отказоустойчивости остается актуальным даже в распределённой среде.
